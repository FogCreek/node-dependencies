#!/usr/bin/env node
// Generated by CoffeeScript 1.6.2
(function() {
  var Dependencies, Package, PackageStatus, async, fs, npm, optimist, opts, path, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  _ = require('underscore');

  async = require('async');

  fs = require('fs');

  npm = require('npm');

  path = require('path');

  optimist = require('optimist').describe('sort', 'Order to print (none, alpha, urgency)').describe('homepage', 'Print the homepage url with each library').describe('pre', 'Check packages with non-numeric patch values')["default"]('sort', 'urgency').alias('h', 'help');

  opts = optimist.argv;

  if (opts.help) {
    optimist.showHelp();
    process.exit(0);
  }

  /* Stuff
  # local revisions
  # relative timestamps
  #
  */


  Dependencies = (function() {
    function Dependencies() {}

    Dependencies.prototype.status = function(next) {
      return async.waterfall([this.package_names, this.package_details], next);
    };

    Dependencies.prototype.package_names = function(next) {
      return async.waterfall([
        function(next) {
          return fs.readdir('node_modules', next);
        }, function(files, next) {
          return async.filter(files, function(filename, next) {
            return fs.exists("node_modules/" + filename + "/package.json", next);
          }, function(res) {
            return next(null, res);
          });
        }
      ], next);
    };

    Dependencies.prototype.package_details = function(packages, next) {
      PackageStatus.header();
      return async.waterfall([
        function(next) {
          return async.map(packages, function(name, next) {
            return new Package(name).status(function(err, status) {
              if (err) {
                PackageStatus.error(name, err);
                return next();
              }
              if (opts.sort !== 'none') {
                return next(null, status);
              } else {
                if (status != null) {
                  status.print();
                }
                return next(null, null);
              }
            });
          }, next);
        }, function(statuses, next) {
          _.chain(statuses).compact().sortBy(function(s) {
            if (opts.sort === 'alpha') {
              return s.name;
            } else {
              return _.values(PackageStatus.FLAG).indexOf(s.status_color(s.diff(s.local, s.remote)));
            }
          }).each(function(s) {
            return s != null ? s.print() : void 0;
          });
          return next();
        }
      ], next);
    };

    return Dependencies;

  })();

  Package = (function() {
    function Package(name) {
      this.name = name;
      this.parse_manifest = __bind(this.parse_manifest, this);
      this.fetch_manifest = __bind(this.fetch_manifest, this);
      this.fetch_remote = __bind(this.fetch_remote, this);
      this.fetch_local = __bind(this.fetch_local, this);
    }

    Package.prototype.status = function(next) {
      var _this = this;
      return this.fetch_information(function(err, _arg) {
        var local, remote, _ref;
        _ref = _arg != null ? _arg : {}, local = _ref.local, remote = _ref.remote;
        return next(err, new PackageStatus(_this, local, remote));
      });
    };

    Package.prototype.fetch_information = function(next) {
      return async.auto({
        local: this.fetch_local,
        remote: this.fetch_remote
      }, next);
    };

    Package.prototype.local_manifest = function() {
      var err;
      try {
        return require(path.resolve(process.cwd(), "./node_modules/" + this.name + "/package.json"));
      } catch (_error) {
        err = _error;
        throw Error("No manifest for " + this.name);
      }
    };

    Package.prototype.fetch_local = function(next) {
      var manifest;
      manifest = this.local_manifest();
      if (!manifest.version) {
        return next(Error("No local manifest found for " + this.name + "."));
      }
      return next(null, manifest.version);
    };

    Package.prototype.fetch_remote = function(next) {
      var _this = this;
      return async.waterfall([
        function(next) {
          return next(null, _this.local_manifest().name);
        }, this.fetch_manifest, this.parse_manifest
      ], next);
    };

    Package.prototype.fetch_manifest = function(name, next) {
      var _this = this;
      return npm.load({
        loglevel: 'silent'
      }, function() {
        return npm.commands.view([name], true, next);
      });
    };

    Package.prototype.parse_manifest = function(manifest, next) {
      var date, latest, number, version, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      latest = _.first(_.values(manifest));
      this.homepage = (_ref = latest != null ? (_ref1 = latest.repository) != null ? _ref1.web : void 0 : void 0) != null ? _ref : latest != null ? (_ref2 = latest.repository) != null ? _ref2.url : void 0 : void 0;
      version = {};
      _ref3 = _.pairs(latest.time);
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        _ref4 = _ref3[_i], number = _ref4[0], date = _ref4[1];
        this.add_version(version, number, new Date(date));
      }
      return next(null, version);
    };

    Package.prototype.add_version = function(store, number, value) {
      var first, rest, _ref, _ref1;
      _ref = number.split('.'), first = _ref[0], rest = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
      if (!first) {
        return value;
      }
      if (!opts.pre && /\D/.test(first)) {
        return store;
      }
      store[first] = this.add_version((_ref1 = store[first]) != null ? _ref1 : {}, rest.join('.'), value);
      return store;
    };

    return Package;

  })();

  PackageStatus = (function() {
    PackageStatus.FLAG = {
      PATCH: 1,
      MINOR: 3,
      MAJOR: 7,
      OK: 2
    };

    PackageStatus.column_data = [['Package', 'rpad', 20], ['Local', 'lpad', 10], ['Major', 'lpad', 10], ['Minor', 'lpad', 10], ['Patch', 'lpad', 10]];

    function PackageStatus(_package, local, remote) {
      this["package"] = _package;
      this.remote = remote;
      if (local) {
        this.local = this.parse_version(local);
      }
    }

    PackageStatus.header = function() {
      return console.log(new PackageStatus().row_format());
    };

    PackageStatus.error = function(name, err) {
      return console.error(name, err.toString());
    };

    PackageStatus.prototype.print = function() {
      var column_contents, status;
      status = this.diff(this.local, this.remote);
      column_contents = [this["package"].name, _.values(this.local).join('.')].concat(this.status_format(status));
      console.log(this.colorize(this.status_color(status))(this.row_format(column_contents)));
      if (opts.homepage && this["package"].homepage) {
        return console.log(this.colorize(5)("  " + (this["package"].homepage.replace(/^git:\/\/github.com/, 'https://github.com'))));
      }
    };

    PackageStatus.prototype.diff = function(version, available) {
      var status;
      return status = {
        major: this.latest(available),
        minor: this.latest(available, [version.major]),
        patch: this.latest(available, [version.major, version.minor])
      };
    };

    PackageStatus.prototype.latest = function(list, prefix) {
      var latest, subver, version_bits;
      if (prefix == null) {
        prefix = [];
      }
      version_bits = _.clone(prefix);
      while ((subver = prefix.shift())) {
        list = list != null ? list[subver] : void 0;
      }
      if (!list) {
        return null;
      }
      latest = this.latest_from(list);
      return {
        version: version_bits.concat(latest).join('.'),
        bit: _.first(latest)
      };
    };

    PackageStatus.prototype.latest_from = function(list) {
      var rest, subversion, _ref;
      if (!(_.size(list) > 0)) {
        return [];
      }
      _ref = _.last(_.pairs(list)), subversion = _ref[0], rest = _ref[1];
      return [subversion].concat(this.latest_from(rest));
    };

    PackageStatus.prototype.status_color = function(status) {
      if (_.compact(_.values(status)).length < 3) {
        return PackageStatus.FLAG.PATCH;
      } else if (this.local.patch !== status.patch.bit) {
        return PackageStatus.FLAG.PATCH;
      } else if (this.local.minor !== status.minor.bit) {
        return PackageStatus.FLAG.MINOR;
      } else if (this.local.major !== status.major.bit) {
        return PackageStatus.FLAG.MAJOR;
      } else {
        return PackageStatus.FLAG.OK;
      }
    };

    PackageStatus.prototype.parse_version = function(version) {
      return _.object(_.zip(['major', 'minor', 'patch'], version.split('.')));
    };

    PackageStatus.prototype.colorize = function(color) {
      return function(str) {
        return "\x1b[3" + color + "m" + str + "\x1b[0m";
      };
    };

    PackageStatus.prototype.row_format = function(cols) {
      var _this = this;
      if (cols == null) {
        cols = [];
      }
      return PackageStatus.column_data.map(function(_arg, i) {
        var args, fn, header, _ref;
        header = _arg[0], fn = _arg[1], args = 3 <= _arg.length ? __slice.call(_arg, 2) : [];
        return _this[fn].apply(_this, [(_ref = cols[i]) != null ? _ref : header].concat(__slice.call(args)));
      }).join(' ');
    };

    PackageStatus.prototype.lpad = function(str, n) {
      return new Array(n + 1).join(' ').concat(str).slice(-n);
    };

    PackageStatus.prototype.rpad = function(str, n) {
      return str.concat(new Array(n + 1).join(' ')).slice(0, n);
    };

    PackageStatus.prototype.status_format = function(status) {
      var key, value, _ref, _results;
      _ref = this.local;
      _results = [];
      for (key in _ref) {
        value = _ref[key];
        if (status[key] == null) {
          _results.push('UNKNOWN');
        } else if (status[key].bit === value) {
          _results.push('---');
        } else {
          _results.push(status[key].version);
        }
      }
      return _results;
    };

    return PackageStatus;

  })();

  new Dependencies().status(function(err, res) {});

}).call(this);
